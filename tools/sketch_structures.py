#!/usr/bin/env python3
"""Generate 2D structure sketches + an optional HTML index (Task 5).

Supports:
- input SMILES files (space/tab/comma separated like calculators)
- results CSV generated by calculators/analyzers

Modes:
- Default (single-view): render one structure per compound, choosing the best
  available SMILES column.
- Compare (visual extension): render multiple structures per compound side-by-
  side (Input vs Prepared vs Calculation) so changes due to preparation,
  tautomer selection, stereo handling, and protomer selection are obvious.

Typical usage:
  python tools/sketch_structures.py results.csv --outdir sketches
  python tools/sketch_structures.py results.csv --format svg,png --html
  python tools/sketch_structures.py results.csv --compare --html

Single-view SMILES priority:
Calc_Canonical_SMILES > Calc_Base_SMILES > Canonical_SMILES > Input_Canonical_SMILES > SMILES

Compare-view columns (with graceful fallbacks):
- Input: Input_Canonical_SMILES (else SMILES)
- Prepared: Canonical_SMILES
- Calc Base: Calc_Base_SMILES
- Calc: Calc_Canonical_SMILES
- (Optional) Protomer: Protomer_Selected_SMILES
"""

from __future__ import annotations

import argparse
import csv
import html
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Import RDKit with a clearer error message if missing.
try:
    from rdkit import Chem
except Exception as e:  # pragma: no cover
    raise SystemExit(
        "RDKit import failed. If you installed rdkit-pypi via pip, ensure you are using numpy<2. "
        "Try: pip install 'numpy<2' && pip install --force-reinstall rdkit-pypi"
    ) from e

# Local utility
sys.path.insert(0, str(Path(__file__).resolve().parents[1] / "calculators"))
from depict import mol_from_smiles, sanitize_filename, save_png, save_svg  # noqa: E402


def parse_smiles_file(path: str) -> List[Tuple[str, str]]:
    items: List[Tuple[str, str]] = []
    with open(path, "r", encoding="utf-8") as f:
        for i, line in enumerate(f, 1):
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split("\t") if "\t" in line else line.split(",") if "," in line else line.split()
            if len(parts) == 1:
                smiles, name = parts[0], f"cmpd_{i}"
            else:
                a, b = parts[0], parts[1]
                looks_smiles_a = any(ch in a for ch in "[]=#@()")
                looks_smiles_b = any(ch in b for ch in "[]=#@()")
                if looks_smiles_a and not looks_smiles_b:
                    smiles, name = a, b
                elif looks_smiles_b and not looks_smiles_a:
                    name, smiles = a, b
                else:
                    name, smiles = a, b
            if Chem.MolFromSmiles(smiles) is None:
                continue
            items.append((name, smiles))
    return items


def detect_id_column(fieldnames: List[str]) -> str:
    for c in ["Compound_ID", "ID", "Name", "Compound", "Molecule"]:
        if c in fieldnames:
            return c
    return fieldnames[0]


def detect_best_smiles_column(fieldnames: List[str]) -> str:
    smiles_priority = [
        "Calc_Canonical_SMILES",
        "Calc_Base_SMILES",
        "Canonical_SMILES",
        "Input_Canonical_SMILES",
        "SMILES",
    ]
    for c in smiles_priority:
        if c in fieldnames:
            return c

    for c in fieldnames:
        if "smiles" in c.lower():
            return c

    raise SystemExit("Could not detect a SMILES column")


def detect_compare_smiles_columns(fieldnames: List[str]) -> Dict[str, Optional[str]]:
    # These are the preferred columns. If missing we keep None and fall back later.
    cols: Dict[str, Optional[str]] = {
        "input": "Input_Canonical_SMILES" if "Input_Canonical_SMILES" in fieldnames else ("SMILES" if "SMILES" in fieldnames else None),
        "prepared": "Canonical_SMILES" if "Canonical_SMILES" in fieldnames else None,
        "calc_base": "Calc_Base_SMILES" if "Calc_Base_SMILES" in fieldnames else None,
        "calc": "Calc_Canonical_SMILES" if "Calc_Canonical_SMILES" in fieldnames else None,
        "protomer": "Protomer_Selected_SMILES" if "Protomer_Selected_SMILES" in fieldnames else None,
    }

    best = detect_best_smiles_column(fieldnames)

    # If prepared missing, fall back to best.
    if cols["prepared"] is None:
        cols["prepared"] = best

    # If input missing, fall back to best.
    if cols["input"] is None:
        cols["input"] = best

    # If one of calc/calc_base missing, fall back to the other; otherwise to best.
    if cols["calc_base"] is None:
        cols["calc_base"] = cols["calc"] or best

    if cols["calc"] is None:
        cols["calc"] = cols["calc_base"] or best

    return cols


def read_csv_rows(path: str) -> Tuple[List[Dict[str, str]], List[str]]:
    with open(path, "r", encoding="utf-8") as f:
        r = csv.DictReader(f)
        if not r.fieldnames:
            raise SystemExit("Empty CSV")
        rows = [row for row in r]
    return rows, list(r.fieldnames)


def write_html_index_single(
    outdir: Path,
    items: List[Dict[str, str]],
    title: str,
    rel_img_paths: Dict[str, Dict[str, str]],
) -> None:
    css = """
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px;}
    h1{margin:0 0 12px 0;font-size:20px;}
    .meta{color:#555;margin-bottom:18px;}
    table{border-collapse:collapse;width:100%;}
    th,td{border-bottom:1px solid #eee;padding:10px;text-align:left;vertical-align:top;}
    th{position:sticky;top:0;background:#fff;}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;}
    img{max-width:280px;height:auto;border:1px solid #eee;border-radius:6px;background:#fff;}
    .smiles{max-width:700px;word-break:break-all;}
    """

    rows_html = []
    for it in items:
        cid = it.get("id", "")
        smi = it.get("smiles", "")
        imgs = rel_img_paths.get(cid, {})
        img_tags = []
        for fmt in ["svg", "png"]:
            if fmt in imgs:
                img_tags.append(f'<div><img src="{html.escape(imgs[fmt])}" alt="{html.escape(cid)}"/></div>')
        rows_html.append(
            "<tr>"
            f"<td><code>{html.escape(cid)}</code></td>"
            f"<td class='smiles'><code>{html.escape(smi)}</code></td>"
            f"<td>{''.join(img_tags)}</td>"
            "</tr>"
        )

    doc = f"""<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>{html.escape(title)}</title>
<style>{css}</style>
</head>
<body>
<h1>{html.escape(title)}</h1>
<div class="meta">Generated by MolProp Toolkit (tools/sketch_structures.py)</div>
<table>
<thead><tr><th>Compound_ID</th><th>SMILES</th><th>Structure</th></tr></thead>
<tbody>
{''.join(rows_html)}
</tbody>
</table>
</body>
</html>
"""

    (outdir / "index.html").write_text(doc, encoding="utf-8")


def write_html_index_compare(
    outdir: Path,
    items: List[Dict[str, str]],
    title: str,
    views: List[str],
    rel_img_paths: Dict[str, Dict[str, Dict[str, str]]],
    smiles_by_view: Dict[str, Dict[str, str]],
) -> None:
    css = """
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px;}
    h1{margin:0 0 12px 0;font-size:20px;}
    .meta{color:#555;margin-bottom:18px;}
    table{border-collapse:collapse;width:100%;}
    th,td{border-bottom:1px solid #eee;padding:10px;text-align:left;vertical-align:top;}
    th{position:sticky;top:0;background:#fff;z-index:1;}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;}
    img{max-width:280px;height:auto;border:1px solid #eee;border-radius:6px;background:#fff;}
    .smiles{max-width:520px;word-break:break-all;}
    .cell{min-width:320px;}
    .label{font-weight:600;margin:0 0 6px 0;}
    details{margin-top:6px;}
    summary{cursor:pointer;color:#333;}
    """

    display = {
        "input": "Input",
        "prepared": "Prepared",
        "calc_base": "Calc Base",
        "protomer": "Protomer",
        "calc": "Calc",
    }

    header_cols = "".join([f"<th class='cell'>{html.escape(display.get(v, v))}</th>" for v in views])

    rows_html = []
    for it in items:
        cid = it.get("id", "")
        tds = [f"<td><code>{html.escape(cid)}</code></td>"]

        for v in views:
            imgs = rel_img_paths.get(cid, {}).get(v, {})
            tags = []
            for fmt in ["svg", "png"]:
                if fmt in imgs:
                    tags.append(f'<div><img src="{html.escape(imgs[fmt])}" alt="{html.escape(cid)}-{html.escape(v)}"/></div>')

            smi = smiles_by_view.get(cid, {}).get(v, "")
            details = (
                f"<details><summary>SMILES</summary><div class='smiles'><code>{html.escape(smi)}</code></div></details>"
                if smi
                else ""
            )

            tds.append(
                f"<td class='cell'><div class='label'>{html.escape(display.get(v, v))}</div>{''.join(tags)}{details}</td>"
            )

        rows_html.append("<tr>" + "".join(tds) + "</tr>")

    doc = f"""<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>{html.escape(title)}</title>
<style>{css}</style>
</head>
<body>
<h1>{html.escape(title)}</h1>
<div class="meta">Generated by MolProp Toolkit (tools/sketch_structures.py) â€¢ Compare view</div>
<table>
<thead><tr><th>Compound_ID</th>{header_cols}</tr></thead>
<tbody>
{''.join(rows_html)}
</tbody>
</table>
</body>
</html>
"""

    (outdir / "index.html").write_text(doc, encoding="utf-8")


def main() -> None:
    ap = argparse.ArgumentParser(description="Generate 2D structure sketches and optional HTML index")
    ap.add_argument("input", help="Input CSV or SMILES file")
    ap.add_argument("--outdir", default="sketches", help="Output directory")
    ap.add_argument("--format", default="svg", help="Comma-separated formats: svg,png")
    ap.add_argument("--width", type=int, default=280)
    ap.add_argument("--height", type=int, default=200)
    ap.add_argument("--max", type=int, default=0, help="Max structures to render (0 = all)")
    ap.add_argument("--html", action="store_true", help="Generate an index.html")
    ap.add_argument("--legend", choices=["id", "none"], default="id", help="Legend text under structure")

    # Visual extension
    ap.add_argument(
        "--compare",
        action="store_true",
        help="Render and display Input vs Prepared vs Calc structures side-by-side (CSV only)",
    )
    ap.add_argument(
        "--include-protomer",
        action="store_true",
        help="In compare mode, include Protomer_Selected_SMILES as an additional column if available",
    )

    args = ap.parse_args()

    in_path = Path(args.input)
    outdir = Path(args.outdir)
    outdir.mkdir(parents=True, exist_ok=True)

    fmts = [x.strip().lower() for x in args.format.split(",") if x.strip()]
    if not fmts:
        raise SystemExit("No formats requested")

    if in_path.suffix.lower() != ".csv" and args.compare:
        raise SystemExit("--compare requires a calculator/analyzer results CSV")

    # Read input
    items: List[Dict[str, str]] = []
    csv_rows: Optional[List[Dict[str, str]]] = None
    fieldnames: Optional[List[str]] = None

    if in_path.suffix.lower() == ".csv":
        csv_rows, fieldnames = read_csv_rows(str(in_path))
        assert fieldnames is not None
        id_col = detect_id_column(fieldnames)

        if args.compare:
            title = f"Structure comparison from {in_path.name}"
            # Store entire row for multi-column extraction
            for row in csv_rows:
                items.append({"id": row.get(id_col, "") or ""})
        else:
            smiles_col = detect_best_smiles_column(fieldnames)
            for row in csv_rows:
                items.append({"id": row.get(id_col, "") or "", "smiles": row.get(smiles_col, "") or ""})
            title = f"Structures from {in_path.name} ({smiles_col})"
    else:
        pairs = parse_smiles_file(str(in_path))
        for cid, smi in pairs:
            items.append({"id": cid, "smiles": smi})
        title = f"Structures from {in_path.name}"

    if args.max and args.max > 0:
        items = items[: args.max]

    # Render
    if not args.compare:
        rel_img_paths: Dict[str, Dict[str, str]] = {}
        for idx, it in enumerate(items):
            cid = it.get("id", "") or f"cmpd_{idx+1}"
            smi = it.get("smiles", "") or ""
            if not smi:
                continue
            m = mol_from_smiles(smi)
            if m is None:
                continue

            fname = sanitize_filename(cid)
            legend = cid if args.legend == "id" else ""

            rel_img_paths[cid] = {}
            for fmt in fmts:
                if fmt == "svg":
                    rel = f"structures/{fname}.svg"
                    save_svg(outdir / rel, m, size=(args.width, args.height), legend=legend)
                    rel_img_paths[cid]["svg"] = rel
                elif fmt == "png":
                    rel = f"structures/{fname}.png"
                    save_png(outdir / rel, m, size=(args.width, args.height), legend=legend)
                    rel_img_paths[cid]["png"] = rel
                else:
                    raise SystemExit(f"Unknown format: {fmt}")

        if args.html:
            write_html_index_single(outdir, items, title=title, rel_img_paths=rel_img_paths)

        print(f"Saved sketches to: {outdir}")
        return

    # Compare mode (CSV)
    assert csv_rows is not None and fieldnames is not None
    id_col = detect_id_column(fieldnames)
    cols = detect_compare_smiles_columns(fieldnames)

    views = ["input", "prepared", "calc_base", "calc"]
    if args.include_protomer and cols.get("protomer") is not None:
        views.insert(3, "protomer")

    # Index rows by compound id
    rows_by_id: Dict[str, Dict[str, str]] = {}
    for row in csv_rows:
        cid = row.get(id_col, "") or ""
        if cid:
            rows_by_id[cid] = row

    # rel_img_paths[cid][view][fmt] = relpath
    rel_img_paths_cmp: Dict[str, Dict[str, Dict[str, str]]] = {}
    smiles_by_view: Dict[str, Dict[str, str]] = {}

    for idx, it in enumerate(items):
        cid = it.get("id", "") or f"cmpd_{idx+1}"
        row = rows_by_id.get(cid)
        if row is None:
            continue

        fname_base = sanitize_filename(cid)
        legend = cid if args.legend == "id" else ""

        rel_img_paths_cmp[cid] = {}
        smiles_by_view[cid] = {}

        for v in views:
            col = cols.get(v)
            smi = (row.get(col, "") if col else "") or ""
            smiles_by_view[cid][v] = smi

            if not smi:
                continue

            m = mol_from_smiles(smi)
            if m is None:
                continue

            rel_img_paths_cmp[cid][v] = {}
            for fmt in fmts:
                if fmt == "svg":
                    rel = f"structures/{fname_base}__{v}.svg"
                    save_svg(outdir / rel, m, size=(args.width, args.height), legend=legend)
                    rel_img_paths_cmp[cid][v]["svg"] = rel
                elif fmt == "png":
                    rel = f"structures/{fname_base}__{v}.png"
                    save_png(outdir / rel, m, size=(args.width, args.height), legend=legend)
                    rel_img_paths_cmp[cid][v]["png"] = rel
                else:
                    raise SystemExit(f"Unknown format: {fmt}")

    if args.html:
        write_html_index_compare(
            outdir,
            items,
            title=title,
            views=views,
            rel_img_paths=rel_img_paths_cmp,
            smiles_by_view=smiles_by_view,
        )

    print(f"Saved sketches to: {outdir}")


if __name__ == "__main__":
    main()

